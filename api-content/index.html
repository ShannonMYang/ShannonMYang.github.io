{"posts":[{"title":"郑州五险一金办理记","content":" 由于，最近在郑州办理一些关于五险一金的手续，跑腿过程中遇到了一丢丢波折。 所以，决定记录一下，希望帮到有需要的人。 由于笔者是从北京回郑州这种跨地区的情况。 所以，别的地方跨地区办理所需东西，不太清楚。 社保 从北京回到郑州，社保能不能转移和衔接上，是很多人关心的问题，笔者亦如是。 下面列举一些笔者问到的问题和工作人员的相关解答。 1. 无工作人员能否开个人社保账户？ 可以开个人社保账户，选择灵活就业进行社保缴纳。需要 注意 的是，灵活就业，仅仅有医疗和养老，两险。 2. 在入职某家公司后，能否将个人缴纳，转到公司缴纳？ 社保的个人转公司，公司转个人，都是可以进行操作的，需要去社保办事处的柜台进行办理业务。 3. 社保可否转移？ 在异地社保进行停保操作后，可进行转移。网上即可操作，下载 掌上12333 App，网上即可办理。无论是公司转个人，还是个人转公司，均可操作进行转移。 4. 在停保之前，能否开始在本地进行开户缴纳社保？ 能开户，但不能缴纳。比如，本月停保，你需要开户的时候，选定从下月开始缴纳社保。 5. 如何个人缴纳社保？ 社保官网查询便民网点，进行开户、缴费操作。 6. 开户后，如何办理社保卡？ 开户后，会拿到一张一式两份的表格。在支付宝市民中心的社保一栏，找到社保预约，进行社保卡相关业务预约，而后在指定时间，携带身份证、表格，前往柜台，工作人员对你的开户信息进行核实后，去往自助机进行办理社保卡。如不会操作，可坚持柜台办理。柜台办理一般需要10个工作日，自助机是现场出卡。 7. 如果以前在河南境内有办理过城镇居民医疗、农村合作医疗此类业务，如何办理社保卡？ 需要预约社保卡业务后，去往柜台，由工作人员挂失掉旧卡，才能办理新卡。 具体参照第6条。 8. 避坑指北 如果可以的话，尽可能去市政综合服务大厅，那里部门更齐全，工作人员更专业。之前去往区办事处，工作人员回复的模棱两可，让人头晕。 公积金 从北京回到郑州，公积金能不能转移和衔接上，也是很多人关心的问题，笔者亦如是。 下面列举一些笔者问到的问题和工作人员的相关解答。 1. 无工作人员能否开个人公积金账户？ 可以开个人公积金账户，选择灵活就业进行公积金缴纳。 ","link":"https://shannonmyang.github.io/post/zheng-zhou-wu-xian-yi-jin-ban-li-ji/"},{"title":"零碎笔记","content":" 这些笔记比较零碎，又不够单独开一篇文章的必要，所以就集中在此处了。 UML类图 ｜ 线与箭头 1. 在UML类图中：实线➕空心三角箭头代表``继承关系`，由子类指向其父类 2. 在UML类图中：虚线➕箭头表示 依赖关系，常用在方法参数等，由依赖方指向被依赖方 3. 在UML类图中：虚线➕空心三角箭头表示 接口实现，由实现方指向接口 4. 在UML类图中：实线➕箭头表示 关联关系，例如，当一个类'知道'另一个类，即一个类引用另一个类 5. 在UML类图中：实线➕空心菱形表示'聚合关系'，聚合表示一种弱的'拥有'关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。例如，大雁是群居动物，每只大雁都是属于一个雁群，一个雁群可以有多只大雁 6. 在UML类图中：实线➕实心菱形➕箭头表示'合成(组合)关系'，合成是一种强的'拥有'关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。合成关系的连线两端还各有一个数字。这被称为基数。表明这一端的类可以有几个实例。关联关系、聚合关系也可以有基数的 类图 类图分三层，第一层显示类的名称，如果是抽象类，则就用斜体表示。第二层是类的特性，通常就是字段和属性。第三层是类的操作，通常是方法或行为。⚠️注意符号，'+'表示public，'-'表示private，'#'表示protected。 接口图 与类图的区别主要是顶端有&lt;&lt;interface&gt;&gt;显示。第一行是接口名称，第二行是接口方法。接口还有另一种表示方法，俗称棒棒糖表示法，圆圈旁是接口名称，接口方法在实现类中出现。 ","link":"https://shannonmyang.github.io/post/ling-sui-bi-ji/"},{"title":"macos 升级 big sur 显示安装所选更新时发生错误","content":" 盼星星盼月亮，终于等到了Big Sur的正式更新，结果，发生错误，于是，查询、解决、记录如下。 网上搜罗了一圈，发现都在说 csrutil enable 这个命令。 注意！若是 融合磁盘 的 Mac 请不要使用此方法，因为 csrutil enable 命令会格式化融合磁盘。届时，电脑上的资料会全部被清空，无法恢复。 若是 闪存 的 Mac 则可以使用以下方法。 遂试了下，但依旧如大多数网友反映的那样，没有什么用处。 后来，无奈之下，就想着会不会是苹果服务器访问量太大，导致的网络波段？ 于是，疯狂点击了几次立即升级，切换了几次WI-FI，居然就开始稳定更新下载了。而后，就顺风顺水的更新成功了。 疑问来了 csrutil enable 这个命令，干嘛用的？ 经过一番查询，发现这个命令，是Mac开启和关闭 系统完整性保护 权限 用的。 Mac 开启关闭 SIP（系统完整性保护） 在我们开发过程中，有时候我们安装一些工具软件需要将文件拷贝到系统限制更改的文件夹中，甚至有时需要更改系统限制的文件，而这时 Mac 会提示系统文件不能修改之类的内容，而这时我们想要继续操作必须关闭 Mac 电脑的 “系统完整性保护” 机制（SIP） 1. 查看 SIP 状态 在终端中输入 csrutil status，就可以看到是 enabled 还是 disabled。 2. 关闭 SIP - 重启 Mac，按住 cmd+R 直到屏幕上出现苹果的标志和进度条，进入 Recovery 模式； - 在屏幕最上方的工具栏找到实用工具（左数第 3 个），打开终端，输入：csrutil disable； - 关掉终端，重启 Mac； - 重启以后可以在终端中查看状态确认。 3. 开启 SIP 与关闭的步骤类似，只是在 第二步中的第二小步 终端中 输入 csrutil enable 即可。 ","link":"https://shannonmyang.github.io/post/macos-sheng-ji-big-sur-xian-shi-an-zhuang-suo-xuan-geng-xin-shi-fa-sheng-cuo-wu/"},{"title":"变成穷人的18中方法","content":" 今天你变穷了么？ 第1种方法：从来不谈论钱 第2种方法：完全没有储蓄习惯 第3种方法：轻信别人的建议 第4种方法：不判断风险，只看收益 第5种方法：没有独立思考的能力 第6种方法：抱有侥幸心理 第7种方法：永远没有行动 第8种方法：从众心理 第9种方法：用时间来省钱 第10种方法：把钱看得比机会更重要 第11种方法：宁愿花时间去省钱，也不愿花时间去学习赚钱 第12种方法：不知道加杠杆可以获得更大的价值 第13种方法：只做紧急的事，不做重要的事 第14种方法：没有概率思维 第15种方法：不寻求改变，不突破自己 第16种方法：做自己不懂的投资 第17种方法：只凭感情冲动，不靠理性判断 第18种方法：不坚持独立思考，屈从于专家 ","link":"https://shannonmyang.github.io/post/bian-cheng-qiong-ren-de-18-zhong-fang-fa/"},{"title":"探究__block本质时，xcrun的报错解决","content":" 近期在研究 block，探究底层的一些东西，遂用到了 xcrun 命令，但是莫名报错，于是就有了如下记录。 在 main.m 所在的文件目录下，输入如下命令行 xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m 报错如下： 分析： 由报错可知，在当前路径下，找不到文件。那应该是 Xcode 的路径的问题，输入如下命令， xcode-select --print-path 见打印。 输入如下命令，验证路径是否正确 xcodebuild -showsdks 果然错误 输入命令，更改错误路径 sudo xcode-select --switch /Applications/Xcode.app/ 再做路径正确与否的验证，输入命令 xcodebuild -showsdks 验证结果 再运行 xcrun 命令，成功无错误 ","link":"https://shannonmyang.github.io/post/tan-jiu-__block-ben-zhi-xcrun-de-bao-cuo-jie-jue/"},{"title":"流年·流水账","content":" 由于上一家公司待得时间久，中间又换过部门，所以前端、移动端、后端，均有涉猎。 技术方面，机器学习Tensorflow、区块链、iOS端、Web端，后端，都有做过，有的多有的少。 通过这么多方面的涉猎，以前没注意过。在某个睡不着的夜晚，开始思考起，写一份总结，以后应该会经常写吧。要不然，总以为自己什么也不会。其实，不知不觉之间，已经会了很多东西。 ","link":"https://shannonmyang.github.io/post/si-shui-liu-nian-zong-jie/"},{"title":"oh-my-zsh 提示不安全信息解决方案","content":" 在安装完 oh-my-zsh 之后，打开 iTerm 会冒出如下的一堆提示信息： [oh-my-zsh] Insecure completion-dependent directories detected: drwxr-xr-x 3 myu admin 96 4 1 11:33 /usr/local/share/zsh drwxr-xr-x 4 myu admin 128 4 2 10:04 /usr/local/share/zsh/site-functions [oh-my-zsh] For safety, we will not load completions from these directories until [oh-my-zsh] you fix their permissions and ownership and restart zsh. [oh-my-zsh] See the above list for directories with group or other writability. [oh-my-zsh] To fix your permissions you can do so by disabling [oh-my-zsh] the write permission of &quot;group&quot; and &quot;others&quot; and making sure that the [oh-my-zsh] owner of these directories is either root or your current user. [oh-my-zsh] The following command may help: [oh-my-zsh] compaudit | xargs chmod g-w,o-w [oh-my-zsh] If the above didn't help or you want to skip the verification of [oh-my-zsh] insecure directories you can set the variable ZSH_DISABLE_COMPFIX to [oh-my-zsh] &quot;true&quot; before oh-my-zsh is sourced in your zshrc file. 解决问题： 我们可以看到下面的提示信息，都是可以帮助我们去解决的。 有两种解决方案。笔者采用的方案是第二种。 1. 按照所有的提示去修改权限即可 chmod 755 /Users/myu/.oh-my-zsh chmod 755 /Users/myu/.oh-my-zsh/plugins chmod 755 /Users/myu/.oh-my-zsh/plugins/git chmod 755 /usr/local/share/zsh chmod 755 /usr/local/share/zsh/site-functions 2. 设置变量 ZSH_DISABLE_COMPFIX=&quot;true&quot; 运行命令 vi ~/.zshrc ，点击 i 键，进行编辑。 在 .zshrc 文件的第一行添加 ZSH_DISABLE_COMPFIX=&quot;true&quot;。 运行 source 命令，重新加载 .zshrc 文件。 source ~/.zshrc 尾声： 按下组合键 command + q，退出 iTerm ，重新打开，发现，清清爽爽，提示信息不见了。 问题解决。 ","link":"https://shannonmyang.github.io/post/oh-my-zsh-ti-shi-bu-an-quan-xin-xi-jie-jue-fang-an/"},{"title":"解决 element-ui 弹出多个 message 的问题","content":" 在当前版本的 element 中，message 消息提示 的一个请求对应一个浮窗提示，这就会导致多条消息提示共存的问题，更多的时候，甚至可以占满一屏。而很多情况下，这多条消息提示的内容是一样的，从用户的体验来说，并不友好。 类似于这样： 如何解决？ 在 src 目录下，创建一个文件夹 common，在 common 文件夹内创建一个 resetMessage.js 。 代码如下： import { Message } from 'element-ui'; let messageInstance = null; const resetMessage = (options) =&gt; { if(messageInstance) { messageInstance.close() } messageInstance = Message(options) }; ['error','success','info','warning'].forEach(type =&gt; { resetMessage[type] = options =&gt; { if(typeof options === 'string') { options = { message:options } } options.type = type return resetMessage(options) } }) export const message = resetMessage 在 main.js 中引用 // 务必要放在Vue.use(ElementUI)之后，因为重写的是element-ui的提示框 import { message } from '@/common/resetMessage.js'; Vue.prototype.$message = message; //重写message提示框 Vue组件中代码的调用 methods: { click() { this.$message({ message: &quot;保存成功！&quot;, type: &quot;success&quot;, }); }, } 此刻，再点击 组件内 之前的 提示框调用，效果如图： 尾声 至此，多条消息提示共同存在的问题，得以解决，页面只会显示和存在一个消息提示 ","link":"https://shannonmyang.github.io/post/jie-jue-element-ui-dan-chu-duo-ge-message-de-wen-ti/"},{"title":"拦住内心的魔兽","content":" 最近看的文章、小说片段、微博，乃至视频剪辑，都在说同一个道理。 夜晚的梦境里，也反反复复得念起这个道理。所以，想了想，打算记录下来，谈一谈这个东西。 儒家学说，自春秋战国流传至今。此处暂不谈论儒家的好与坏、功与过。只是简单的说出来，我自己对于儒家学说中比较赞同的一些观点。 作为一个从没做过生意，也就是大学毕业那会儿卖书，比着别人多卖出好几倍的价钱。在19年的时候，无意间通过微博博主@写书哥，推荐的一个开工厂做生意的微博博主。时不时会翻微博看到这位博主写的一些观点。偶尔有趣、偶尔吐槽、偶尔洒脱、偶尔说些我看不懂的生意经。 20年因为新冠肺炎疫情的缘故，在家无聊翻微博的时候，看到这位微博博主说她自己的儿子。说假期期间放任不管，全凭自觉，但是冷眼旁观。而后，谈过一次话。其中就提到了儒家的思想——克己。 记得有句健身口号好像贼火，被好多写鸡汤的公众号拿来反反复复地用。原话是：「自律给我自由」。自律能不能给你自由，我不清楚。但是，克己，真的很有必要。 公司一老哥，喜美食、爱聚餐。但，不知是怕寂寞，还是人多容易食物种类丰富。这老哥，每次都会以各种各样的理由，约我们这些程序员铁憨憨吃饭。而我们又不是特别聚餐，反而是喜欢宅的群体。所以，百般推脱。终于，成功打消了这老哥的约吃饭习惯。 这里说到的克己，就是克制自己不忍拒绝别人的年头，该拒绝拒绝，没必要的聚会，该推就推。那，替换出来的时间，就是任你分配的。当然，若是真想吃肉，又不想减肥，当我没说。 儒家说的克己，是君子慎独，是不欺暗室。 简单来说就是，人前人后一样，言与行相随，是真正的正直。 之前看一本书，作者提及自己采访的一个业界内的前辈。说前辈几十年如一日的习惯养成让其好奇。于是采访之余，就开口问及了。前辈回答的很简单，但也很难做到。几十年如一日，这一点就很难。更何况是每次面对外界的诱惑的时候，就牢牢关紧内心魔兽的笼门。一次拦着或许不难，几十年如一日，才是最难。万事怕坚持。 在看完《雪中悍刀行》后，看的最久的小说，当属目前在看的这本《剑来》。主人公陈平安无论外界如何诱惑，始终坚持自己认定的道理和本心，不动不摇，逐渐登高行远。记不清在哪次胡乱翻看章节的时候，陈平安说的也是大概和上一段提到的前辈讲的类似的话语。 因为，不知道自己哪一次会走错，也不知道自己哪一次会顶受不住外界的诱惑，更不知道自己哪一次会无法克制自己。所以，干脆一次都不去犯，一次都不去做。 巧的是，前两天看到一篇微博内容，说的是，每年开学，央视电视台会让人认领那些特别贫困的学生，予以资助大学的学费。其中，高晓松自己也认领了。但是，快开学的时候，他接到受资助者的电话，说自己考上了浙大，目前已经有人资助自己了，并表示了感谢。高晓松表示不可理解，说，你多接受一份资助，不挺好么，你也可以轻松一点。这位学生说道，「人有了不要脸的第一次，就会有后面的第二次第三次乃至无数次。所以，一次都不要有。」 这便是，克己，多么正的三观。 这么多年，一直难有看得下去的小说，就是因为，像《剑来》三观正直的小说，太少了。所有的读者都在追求快感，所有的写手都在博眼球。 昨天看媳妇儿在刷抖音，好像是奇葩说的剪辑。话题感觉像是说的夫妻感情。 里面说到，人其实善变的，喜新厌旧的。所以，婚姻的发明，其实是很反人类的。你不能要求另一半一直对你死心塌地，一直爱你。但是，他如果在人生的这趟列车上，看过了诸多路人，但是，从没跟任何人下车的举动。反而是拒绝了诸多，坚定的愿意跟你一直走下去。 那也是克己。 这世间的诱惑太多，长得好的、身材好的，比比皆是，你总不能见一个爱一个吧？ 所以，我始终赞同的是，从一而终爱一个人的那种。也就是古人向往以及现代很多人向往的，执子之手，与子偕老。 当然，你可以归因于过去车马慢，通讯不发达，所以，诱惑没那么多。 但是，正因为现在的诱惑多，而你能挡得住诱惑，从一而终，不更是难能可贵么！ 刚结婚不久的我，不懂那些出轨的人怎么想。当然，我在很小的时候也不懂，看过好多结婚、离婚的人和事。我不禁思考，难道这些人不懂得车离开了轨道一定会出事的么？难道这些人不懂得家和才能万事兴？ 或许他们懂得，或许他们不想懂，或许他们装作不懂。 可是，我觉得，克己，很有必要。既然不想让其发生。那就一次索性不让它发生。 焊牢魔兽的笼门，或者干脆扔下深渊底的深潭里。 克己，不单单是自律。 是要拒绝千般诱惑，是要明白自己想要的东西，剥去斑杂，为之努力经营。 只要你心诚志坚，念念回首处，必是灵山。 ","link":"https://shannonmyang.github.io/post/lan-zhu-nei-xin-de-mo-shou/"},{"title":"相似联想","content":"19年一整年的时间，翻了好多书。 易经衍生的书籍、计算机类的书籍、地理方面的书籍，都有看过。 高三那年吧，由于每天密集式的刷试卷。作文这个让很多人头疼的东西，也就在必刷之列。 当时的我，为了找寻作文写作用的材料，翻了不少杂志、作文指导书籍。 记得有一篇杂志文章写的是关于各个公司的宣传语的，其中，联想的广告语最让我印象深刻。说的是，「如果没有联想，世界将会怎样。」一语双关，非常妙。 当然，写这篇文章不是为了说联想如何如何。而是为了说，相似联想，这个东西的重要性。 之前部门老大，亦是公司首席科学家，一个拥有美国绿卡，为美国地震局、某个州的监狱以及AMD产线写过系统，且至今仍在运行，时不时要接国际长途电话，远程指导并收费的长者。 在一次部门会议的时候，语重心长的对我们几个小伙子说道，「你们啊，要好好看看计算机的底层原理，再看看中国的易经、阴阳太极之说的书籍。」 当时大家嘿嘿一笑，没当回事。 19年翻阅了诸多计算机底层书籍，老大的话就愈发印象深刻，尤其是在翻看一本名为《编码·隐匿在计算机背后的语言》书籍时，才恍然发觉部门老大所言的东西，未尝不是没道理的。 看着《编码》一书，不禁感慨老祖宗们的伟大思想。计算机中最基础部分的0和1，组成了现在看到的千千万万的信息流。0和1，不正像极了，阴与阳之说。阴阳生万物，01组成计算机世界。当然，0和1的本质，也就是对应着电流的正负。随之，会联想到原子、夸克一系列微小的单位，正是这些小到不能更小的东西，组成了世界万物。 联想到这些，不得不感慨，原来我们的世界，竟然是如此简单的组成，却又如此纷繁复杂。 ","link":"https://shannonmyang.github.io/post/xiang-si-lian-xiang/"},{"title":"更换Win10系统的字体","content":"天下苦偶尔用macOS偶尔用Win10的用户久已。 由于我是一个工作用Windows10操作系统，闲暇用macOS操作系统的搬砖民工。 所以，每当我看到Windows10操作系统自带默认的微软雅黑，我简直无力吐槽。尤其是对于我这种搬砖民工来讲，写代码的时候，微软雅黑，简直不能更具备瞎了眼的功力。 当然，这不是本文的缘由。一天写代码闲暇时光里，我看到一篇文章，是在说为什么小米10不能称为高端机。引出了成也MIUI，败也MIUI的话题。其中就说到了小米兰亭Pro，说这款是仅次于San Francisco的字体。 遂，勾起了修改系统默认字体的好奇心。于是，进行了下载和替换字体。 1. 下载 San Francisco 字体 从下载好的字体中，选择好你需要的，双击，进行安装 2. 复制字体名称 找到字体库，路径是C盘-&gt;Windows-&gt;Fonts，找到San Francisco字体，右键属性，复制如图所示框起来的名称； 3. 修改注册表 按下快捷键组合：Win + R ，在输入框中输入regedit 看到弹出的窗口，输入如下路径 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts 点击鼠标右键，选择 修改菜单，将数值数据 修改为你拷贝来的名字，然后点击确定按钮。 4. 重启电脑 重启电脑，你就会看到一个全新的世界。 上面的截图，即是重启后，字体全面覆盖生效的效果。 自此，你告别了Win10的微软雅黑。 ","link":"https://shannonmyang.github.io/post/geng-huan-win10-xi-tong-de-zi-ti/"},{"title":"Vue.js 中引入 Font Awesome 字体图标","content":" 这，基本是一个被写烂了的话题，但是，我刚接触，我的博客里也没有。故而，有此记录。 1. 安装基础依赖 进入 Vue 项目文件夹，执行如下命令安装基础依赖库。 npm i --save @fortawesome/fontawesome-svg-core npm i --save @fortawesome/vue-fontawesome 2. 安装样式依赖 Font Awesome 为我们提供了 Solid、Regular、Brands 这三种免费样式（日常使用完全够用），执行如下命令安装。 npm i --save @fortawesome/free-solid-svg-icons npm i --save @fortawesome/free-regular-svg-icons npm i --save @fortawesome/free-brands-svg-icons 3. 修改 src/main.js 添加如下代码全局引入并配置 Font Awesome，之后我们就可以使用它了。 // 引入fontawesome-icon import { library } from '@fortawesome/fontawesome-svg-core' import { fas } from '@fortawesome/free-solid-svg-icons' import { far } from '@fortawesome/free-regular-svg-icons' import { fab } from '@fortawesome/free-brands-svg-icons' import { FontAwesomeIcon, FontAwesomeLayers, FontAwesomeLayersText } from '@fortawesome/vue-fontawesome' library.add(fas, far, fab) Vue.component('font-awesome-icon', FontAwesomeIcon) Vue.component('font-awesome-layers', FontAwesomeLayers) Vue.component('font-awesome-layers-text', FontAwesomeLayersText) 4. 基本使用 4.1 显示图标 a. 我们使用 font-awesome-icon 标签来显示图标，icon 属性中可以设置样式前缀、以及图标名字。 &lt;font-awesome-icon :icon=&quot;['fas', 'square']&quot;/&gt; &lt;font-awesome-icon :icon=&quot;['far', 'square']&quot;/&gt; &lt;font-awesome-icon :icon=&quot;['fab', 'accessible-icon']&quot;/&gt; b. 如果是 solid 样式（前缀为：fas），则前缀可以省略。比如上面第一个图标等效下面写法： &lt;font-awesome-icon icon=&quot;square&quot;/&gt; 4.2 设置图标大小 默认情况下图标和当前文字的大小是一样的。我们可以通过 size 属性在此基础上作调整，该属性支持多种类型的设置方式。 &lt;font-awesome-icon icon=&quot;chess-knight&quot;/&gt; &lt;font-awesome-icon icon=&quot;chess-knight&quot; size=&quot;xs&quot;/&gt; &lt;font-awesome-icon icon=&quot;chess-knight&quot; size=&quot;lg&quot;/&gt; &lt;font-awesome-icon icon=&quot;chess-knight&quot; size=&quot;2x&quot;/&gt; 4.3 固定图标宽度 使用 fixed-width 可以固定图标宽度。 &lt;font-awesome-icon icon=&quot;home&quot; fixed-width /&gt; home &lt;br&gt; &lt;font-awesome-icon icon=&quot;child&quot; fixed-width /&gt; help &lt;br&gt; &lt;font-awesome-icon icon=&quot;cog&quot; fixed-width /&gt; settings &lt;br&gt; 4.4 旋转图标 &lt;font-awesome-icon icon=&quot;chess-knight&quot; rotation=&quot;0&quot; /&gt; &lt;font-awesome-icon icon=&quot;chess-knight&quot; rotation=&quot;90&quot; /&gt; &lt;font-awesome-icon icon=&quot;chess-knight&quot; rotation=&quot;180&quot; /&gt; &lt;font-awesome-icon icon=&quot;chess-knight&quot; rotation=&quot;270&quot; /&gt; 4.5 翻转图标 &lt;font-awesome-icon icon=&quot;chess-knight&quot; /&gt; &lt;font-awesome-icon icon=&quot;chess-knight&quot; flip=&quot;horizontal&quot; /&gt; &lt;font-awesome-icon icon=&quot;chess-knight&quot; flip=&quot;vertical&quot; /&gt; &lt;font-awesome-icon icon=&quot;chess-knight&quot; flip=&quot;both&quot; /&gt; 4.6 旋转动画效果 4.6.1 添加 spin 属性可以让图标不停地顺时针旋转； &lt;font-awesome-icon icon=&quot;arrow-circle-down&quot; spin /&gt; 4.6.2 添加 pulse 属性同样可以让图标旋转，但它不像 spin 那样是均匀地变化角度，而是 0 度、45 度、90 度... 这样跳跃地变化 &lt;font-awesome-icon icon=&quot;arrow-circle-down&quot; pulse /&gt; ","link":"https://shannonmyang.github.io/post/vuejs-zhong-yin-ru-font-awesome-zi-ti-tu-biao/"},{"title":"Mac 系统常规指令","content":"工欲善其事，必先利其器。 对于开发者来讲，常用指令就是如此。 // 查看当前所在位置 pwd // 查看当前文件夹中的内容 ls // 进入指定目录 cd // 创建一个文件夹 mkdir 文件夹名称 // 删除一个文件夹 rmdir 文件夹名称 // 返回上一级 cd ../ // 清空终端当前一屏（效果类似于你大学课堂上那种上下推拉的黑板，写满一版，往上一推） clear // 打开一个文件 open 文件名称 // 创建一个文件 touch 文件名称 // 查看一个文件 cat 文件名称 ","link":"https://shannonmyang.github.io/post/mac-xi-tong-chang-gui-zhi-ling/"},{"title":"npm 管理依赖包版本","content":" 近来，在做一些 vue.js 相关的练习，用到了很多 npm 管理依赖包的问题。遂，有此笔记，做一记录。 npm 管理 node 版本 1. 安装： $ sudo npm install -g n 2. 查看当前已经安装的 node 版本以及正在使用的版本（前面有一个 o） $ n 3. 安装其他的 node 版本 //安装0.11.12版本 $ n 0.11.12 //安装最新的版本 $ n latest //安装稳定版本 $ n stable // 删除某个版本 $ n rm 0.10.1 4. 以指定的版本来执行脚本 $ n use 0.10.21 some.js 使用 nrm 切换 npm 源 // 安装nrm： npm install -g nrm // 查看已有的可以使用的源 nrm ls // 测试源的速度 nrm test // 切换到现有的源 如 nrm use taobao 之后使用npm就会从taobao下载 nrm use &lt;源名称&gt; // 新增源 nrm add&lt;源名称&gt; &lt;源地址&gt; 部分常用命令 1. 安装命令 // 全局安装 npm install 模块名 -g // 本地安装 npm install 模块名 // 一次性安装多个 npm install 模块1 模块2 模块3 // 安装开发时依赖包 npm install 模块名 --save-dev // 安装运行时依赖包 npm install 模块名 --save 2. 查看安装的目录 // 查看项目中模块所在的目录 npm root // 查看全局安装的模块所在目录 npm root -g 3. 查看某个包的各种属性 // 查看某个包对于各种包的依赖关系 npm view 模块名 dependencies 4. 查看包的源文件地址 // 查看包的源文件地址 npm view 模块名 repository.url 5. 查看 npm 的版本 npm -v 6. 查看某个模块的 bugs 列表界面 npm bugs 模块名 // 例如运行npm bugs antd则会打开antd仓库的issue 7. 打开某个模块的仓库界面 npm repo 模块名 // 例如运行npm repo vue则会打开vue线上仓库，效果如下图 8. 打开某个模块的文档 npm docs 模块名 // 例如运行npm docs vue则会打开vue的readme.md文档 9. 打开某个模块的主页 npm home 模块名 // 例如运行npm home vue则会打开vue模块的主页 10. 查看当前已经安装的模块 npm list // 当然我们也可以限制输入的模块层级，例如 npm list --depth=0 11. 清除未被使用到的模块 // 有时在我们使用npm list的时候，可能会碰到一些问题，就是有些模块并没有被项目引用使用，我们还是安装了这些模块，那么我们可以一键清除这些没有使用到的模块 npm prune 12. 初始化 npm init // 引导你创建一个package.json文件，包括名称、版本、作者这些信息 13. 清除 npm 的缓存 rm -rf node_modules npm cache clean // 慎重使用改命令 npm cache clean -f 14. 卸载 node 模块 npm uninstall 模块名 15. 更新 node 模块 npm update 模块名 // 当然你也可以update 该模块到指定版本 npm update 模块名 @版本号 // 如果安装到最新版本可以使用以下命令 npm install 模块名@latest 16. 查看当前模块依赖的 node 最低版本号 npm view 模块名 engines 17. 查看模块的当前版本号 npm view 模块名 version // 需要注意的是查看到的模块版本是该模块再远程仓库的版本号，并不是当前项目中所依赖的版本号。 // 查看当前项目中应用的某个模块的版本号的命令为 npm list 模块名 version 语义化版本号 每个版本号都形如 1.2.3，由三个部分组成，依次叫做 “主版本号”、“次版本号” 和 “修订号” 当新版本无法兼容基于前一版本的代码时，则提高主版本号 当新版本新增了功能与特性，但仍兼容前一版本的代码时，则提高次版本号 当新版本仅仅修正漏洞或者增强效率，仍然兼容前一版本代码，则提高修订号 默认情况下，npm install --save 下载的都是最新版本，并且会在 package.json 文件里登记一个最优版本号， &quot;cluster&quot;: &quot;&gt;= 0.7.7&quot;, // cluster 版本必须大于等于 0.7.7 或者限定版本范围 npm install cluster@&quot;&gt;=0.7.7&lt;0.8.0&quot; &quot;commander&quot;: &quot;^2.6.0&quot;, /* ^会匹配最新的大版本依赖包，=大版本不变即可,其他版本随便更新。 当我们npm install 的时候,安装到 node_modules 目录下的 commander开源包可能是 2.6.0 或 2.7.3 或 2.8.9 ......不包括3.0.0 只要前面2不变即可.这种版本限制相对对宽松,还是少用为妙.*/ &quot;commander&quot;: &quot;~1.2.3&quot;, /* ~会匹配最近的小版本依赖包，比如~1.2.3会匹配所有1.2.x版本， 但是不包括1.3.0*/ &quot;async&quot; : &quot;1.2.3&quot;, // 指定特定的版本号 npm install async@1.2.3 &quot;async&quot; : &quot;*&quot;, // 最糟糕的一种版本控制,一点限制没有. 使用 npm shrinkwrap 命令锁定项目依赖 在开发某个 Node 项目时，进行到某个节点，一切都运行顺利，说明目前所有的依赖包（以及更底层的依赖包）和你的代码兼容得很好。这个时候，就可以在项目文件夹下运行上面的这个命令。它会生成一个 npm-shrinkwrap.json 文件，记录目前所有依赖包（及更底层依赖包）的版本信息。这样当以后你（或者你的同事、你的用户）运行 npm install 命令时，npm 首先会找 npm-shrinkwrap.json 文件，依照其中的信息来准确地安装每一个依赖包，只有当这个文件不存在时，npm 才会使用 package.json。 在这之后开发的过程中，如果想要更新某个依赖包，比如将 Express 从 4.13.0 更新到 4.14.1，那么就只需 npm install express@4.14.1；或者想要添加新的依赖包，比如 Helmet，也只需 npm install helmet。经过一段时间的测试与开发，当你确定这些新版本新安装的依赖包与自己的代码兼容后，就可以再次运行 npm shrinkwrap 命令来锁定依赖包的版本。 如果 package-lock.json 和 npm-shrinkwrap.json 存在于包的根，package-lock.json 将被完全忽略。 // 在（当前机器的当前用户的）所有项目禁用 package-lock.json npm config set package-lock false 查看 npm 的配置 npm config list 更换源 // 要更换国内镜像，编辑 ~/.npmrc 加入下面内容 registry = https://registry.npm.taobao.org ","link":"https://shannonmyang.github.io/post/npm-guan-li-yi-lai-bao-ban-ben/"},{"title":"Xcode 10 升级后的 Error: Multiple commands produce","content":" 之前一直没有更新 Xcode，最近 2019WWDC 也结束了，SwiftUI 刷爆了 iOS 圈。 遂，更新了 Xcode ，然后，再打开自己的项目，点击 Command+R，华丽丽得扑街。 于是，Google 搜索一番，解决了问题，顺带记录一下。 Error如下 Multiple commands produce '.../.../.../.../.../info.plist' //或者是 Multiple commands produce '.../.../.../.../.../xxx.app' 原因如下 Apple 在 Xcode 10 默认使用的 Build system 是 New Build System，与 Xcode9 使用的 Legacy Build System 不同而导致的。 解决办法 1. 不修改 Build System Solution -&gt; Open target -&gt; Build phases &gt; Copy Bundle Resources and remove info.plist from there. .../.../xxx.app 类型错误 target -&gt; Build phase -&gt; Copy Pods Resources -&gt; Output Files -&gt; 移除 TARGETBUILDDIR/{TARGET_BUILD_DIR}/TARGETB​UILDD​IR/{UNLOCALIZED_RESOURCES_FOLDER_PATH} -&gt; clean -&gt; 重新编译 '.../.../info.plist' 类型错误 target -&gt; 'Build phases' -&gt; 'Copy Bundle Resources' -&gt; 移除 info.plist -&gt; clean -&gt; 重新编译 2. 修改 `Build System' Xcode 菜单栏 -&gt; File -&gt; Workspace Setting，将 build system 修改为 legacy build system，先 clean，然后重新编译。 ","link":"https://shannonmyang.github.io/post/xcode-10-sheng-ji-hou-de-error-multiple-commands-produce/"},{"title":"iOS 打破 NSTimer 循环引用","content":" 在做 iOS 项目，多多少少都会有不留意时候，碰到一些 NSTimer 的 循环引用问题。 本篇笔记意在记录解决 NSTimer 循环引用问题的方法。 本篇笔记将逐一列出解决方法，并附上具体代码实现。 1. 一种方式 打断循环引用 通过弱引用 但必须是在 block 中。 代码调用及实现，如下： __weak typeof(self) weakSelf = self; self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 repeats:YES block:^(NSTimer * _Nonnull timer) { [weakSelf timerLog]; }]; 2. 自己实现一个 block 打破循环引用 （个人感觉，略复杂）。 代码调用如下： self.timer = [NSTimer dix_timerWithTimeInterval:1 repeats:YES block:nil]; 代码实现如下： + (NSTimer *)dix_timerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *))block { return [self scheduledTimerWithTimeInterval:interval target:self selector:@selector(timerAction:) userInfo:[block copy] repeats:repeats]; } //通过 Block 打破循环引用，解决 Timer 无法释放的问题 + (void)timerAction:(NSTimer *)timer { // void (^block)(NSTimer *tiemr) = timer.userInfo; // 声明Block void (^ block)(NSTimer *) = ^(NSTimer *timer) { timer = timer.userInfo; }; NSLog(@&quot;%s&quot;, __func__); if (block) { block(timer); } } 3. 创建中间对象 打破循环引用 代码调用如下： self.timer = [NSTimer scheduledTimerWithTimeInterval:1 target:[dixProxy1 dixProxyWithTarget:self] selector:@selector(timerLog) userInfo:nil repeats:YES]; 代码实现如下： // disProxy1.m + (instancetype)dixProxyWithTarget:(id)target { dixProxy1 *proxy = [[dixProxy1 alloc] init]; proxy.target = target; return proxy; } // 利用runtime的消息转发机制 - (id)forwardingTargetForSelector:(SEL)aSelector { return self.target; } 4. 效率更高 NSProxy , 专门用来做转发的 代码调用如下： /** * 因为在调用 timeLog 方法的时候，发现自身没有，就会自动进入消息转发，进而调用方法 * 而不是像继承自 NSObject，还要在自身没有方法之后，去查找superClass 内是否有方法 * 故而 效率更高 */ self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:[dixProxy2 dixProxyWithTarget:self] selector:@selector(timerLog) userInfo:nil repeats:YES]; 代码实现如下： + (instancetype)dixProxyWithTarget:(id)target { // NSProxy 对象不需要调用init方法， 因为 NSProxy本来就没有 init 方法 dixProxy2 *proxy = [dixProxy2 alloc]; proxy.target = target; return proxy; } - (NSMethodSignature *)methodSignatureForSelector:(SEL)sel { return [self.target methodSignatureForSelector:sel]; } - (void)forwardInvocation:(NSInvocation *)invocation { [invocation invokeWithTarget:self.target]; } ","link":"https://shannonmyang.github.io/post/ios-da-po-nstimer-xun-huan-yin-yong/"},{"title":"iOS 离屏渲染优化简单分析","content":" 最近在做一个小项目的时候，涉及到了 切圆角问题。联想到之前看过的 性能优化分析 相关文章，遂有了重新对 离屏渲染 的小小研究。 在 iOS 的应用开发过程中，多多少少的会遇到 卡顿 的现象。 纵然 iOS 设备的性能日益强大，但是卡顿的现象还是有可能不可避免的出现，而离屏渲染是造成卡顿的原因之一。 本文主要分析一下离屏渲染产生的原因及避免的方法，最后介绍一下 Xcode 自带的分析离屏渲染的工具 Instruments 的使用。 1. UIView 和 CALayer 关系 UIView 继承自 UIResponder，可以处理系统传递过来的事件，如：UIApplication、UIViewController、UIView，以及所有从 UIView 派生出来的 UIKit 类。每个 UIView 内部都有一个 CALayer 提供内容的绘制和显示，并且作为内部 RootLayer 的代理视图。 CALayer 继承自 NSObject 类，负责显示 UIView 提供的内容 contents。CALayer 有三个视觉元素：背景色、内容和边框，其中，内容的本质是一个 CGImage。 下图为 CALayer 的结构图： 界面渲染过程 RunLoop 有一个 60fps 的回调，即每 16.7ms 绘制一次屏幕，所以 view 的绘制必须在这个时间内完成，view 内容的绘制是 CPU 的工作，然后把绘制的内容交给 GPU 渲染，包括多个 View 的拼接（Compositing）、纹理的渲染 (Texture) 等等，最后显示在屏幕上。但是，如果无法是 16.7ms 内完成绘制，就会出现丢帧的问题，一般情况下，如果帧率保证在 30fps 以上，界面卡顿效果不明显，那么就需要在 33.4ms 内完成 View 的绘制，而低于这个帧率，就会产生卡顿的效果，影响体验。 渲染的过程如下： UIView 的 layer 层有一个 content，指向一块缓存，即 backing store UIView 绘制时，会调用 drawRect 方法，通过 context 将数据写入 backing store 在 backing store 写完后，通过 render server 交给 GPU 去渲染，将 backing store 中的 bitmap 数据显示在屏幕上 2. 离屏渲染 在使用圆角、阴影和遮罩等视图功能的时候，图层属性的混合体被指定为在未预合成之前不能直接在屏幕中绘制，所有就需要在屏幕外的上下文中渲染，即离屏渲染。 3. 离屏渲染卡顿原因 离屏渲染之所以会特别消耗性能，是因为要创建一个屏幕外的缓冲区，然后从当屏缓冲区切换到屏幕外的缓冲区，然后再完成渲染；其中，创建缓冲区和切换上下文最消耗性能，而绘制其实不是性能损耗的主要原因。 设置了以下属性时，就会触发离屏绘制： shouldRasterize（光栅化） masks（遮罩） shadows（阴影） edge antialiasing（抗锯齿） group opacity（不透明） 复杂形状设置圆角等 渐变π 屏幕渲染类型 CPU 计算好显示内容提交到 GPU，GPU 渲染完成后将渲染结果放入帧缓冲区，随后视频控制器会按照 VSync 信号逐行读取帧缓冲区的数据，经过可能的数模转换传递给显示器显示。 屏幕渲染有如下三种： 1、GPU 中的屏幕渲染：On-Screen Rendering 意为当前屏幕渲染，指的是 GPU 的渲染操作是在当前用于显示的屏幕缓冲区中进行 2、GPU 中的屏幕渲染：Off-Screen Rendering 意为离屏渲染，指的是 GPU 在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作 3、CPU 中的离屏渲染（特殊离屏渲染，即不在 GPU 中的渲染） 如果我们重写了 drawRect 方法，并且使用任何 Core Graphics 的技术进行了绘制操作，就涉及到了 CPU 渲染。 CoreGraphic 通常是线程安全的，所以可以进行异步绘制，显示的时候再放回主线程 4. 切圆角优化 切圆角是开发 app 过程中经常会用到的功能，但是使用不同的方式，性能损耗也会不同，下面会介绍 3 种切圆角的方法；其中，方法三的性能相对最好。 方法一 使用 cornerRadius 进行切圆角，在 iOS9 之前会产生离屏渲染，比较消耗性能，而之后系统做了优化，则不会产生离屏渲染，但是操作最简单 iv.layer.cornerRadius = 30; iv.layer.masksToBounds = YES; 方法二 利用 mask 设置圆角，利用的是 UIBezierPath 和 CAShapeLayer 来完成 CAShapeLayer *mask1 = [[CAShapeLayer alloc] init]; mask1.opacity = 0.5; mask1.path = [UIBezierPath bezierPathWithOvalInRect:iv.bounds].CGPath; iv.layer.mask = mask1; 方法三 利用 CoreGraphics 画一个圆形上下文，然后把图片绘制上去，得到一个圆形的图片，达到切圆角的目的。 - (UIImage *)drawCircleImage:(UIImage*)image { CGFloat side = MIN(image.size.width, image.size.height); UIGraphicsBeginImageContextWithOptions(CGSizeMake(side, side), false, [UIScreen mainScreen].scale); CGContextAddPath(UIGraphicsGetCurrentContext(), [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, side, side)].CGPath); CGContextClip(UIGraphicsGetCurrentContext()); CGFloat marginX = -(image.size.width - side) * 0.5; CGFloat marginY = -(image.size.height - side) * 0.5; [image drawInRect:CGRectMake(marginX, marginY, image.size.width, image.size.height)]; CGContextDrawPath(UIGraphicsGetCurrentContext(), kCGPathFillStroke); UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return newImage; } ","link":"https://shannonmyang.github.io/post/ios-chi-ping-xuan-ran-you-hua-jian-dan-fen-xi/"},{"title":"Xcode10 中用到 libstdc++6.0.9.tbd 导致的问题","content":" 最近升级了 Xcode 10 版本，运行起之前的项目，各种问题一并爆发。 查了下，是 Xcode 升级导致的 ，Apple早在 Xcode 8 中就废弃了 libstdc++, 给了开发者两年时间过渡，如今在 Xcode 10 中已不再支持。在 Build Phases &gt; Link Binary With Libraries 中已经搜不到 libstdc++ 的库了，Apple给出的原因是 std 库比较旧了，建议使用新版本替换，比如用 libc++.tbd 替换 libstdc++6.0.9.tbd。 没错，上述就是问题报错的所在。 导致之前依赖 libstdc++6.0.9.tbd 的工程，在升级到 Xcode10 后出现编译错误。 错误的具体信息如图所示： 出现这个问题的原因之一，是因为在开发中使用了第三方库，并且第三方库的 podspec 中 libraries 指定了 stdc++6.0.9，Cocoapods 在安装依赖过程中，会在指定 target 下的 other link flag 中加入 -l &quot;stdc++6.0.9&quot; 导致编译不能通过。 由于每个人出现问题的不同，所以此处列举出三种方式。 笔者用的第二种方式解决的自己遇到的编译不通过的问题。 1. 解决方式 1⃣️：处理 pod 的依赖 可以通过使用 Cocoapods 的 post_install hooks 来解决，解决的方法是在 podfile 中加入下面的代码，去掉所有 pod 对 stdc++6.0.9 的依赖： #该方法会移除 所有pod 对stdc++.6.0.9库的依赖，建议仅在Xcode10上使用 post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| puts config.build_settings xcconfig_path = config.base_configuration_reference.real_path build_settings = Hash[*File.read(xcconfig_path).lines.map{|x| x.split(/\\s*=\\s*/, 2)}.flatten] build_settings['OTHER_LDFLAGS'][' -l&quot;stdc++.6.0.9&quot;'] = '' File.open(xcconfig_path, &quot;w&quot;) do |file| build_settings.each do |key,value| file.puts &quot;#{key} = #{value}&quot; end end end end end Ps: 这段 hooks 的原理是：找到所有的 target 的 Pods-TargetName.debug.xcconfig 和 Pods-TargetName.release.xcconfig 这两个文件（在 Pod/Targets Support Files/TargetName 目录下），然后将其中的 OTHER_LDFLAGS 字段中的 - l &quot;stdc++.6.0.9&quot; 去掉。 2. 解决方式 2⃣️：删除 libstdc++(libstdc++.6、libstdc++6.0.9) 库，然后添加 libc++ 库 步骤：TARGETS—&gt;Build Phases—&gt;Link Binary With Libraries，删除 libstdc++(libstdc++.6、libstdc++6.0.9) ，添加 libc++； 3. 解决方式 3⃣️：删除掉第三方库中对 libstdc++ 的依赖 a. Pods —&gt; Targets Support Files —&gt; Pods-XXXX.debug.xcconfig，查找 libstdc++(libstdc++.6、libstdc++6.0.9)，将其删除； b. Pods —&gt; Targets Support Files —&gt; Pods-XXXX.release.xcconfig，查找 libstdc++(libstdc++.6、libstdc++6.0.9)，将其删除； 如图所示: ","link":"https://shannonmyang.github.io/post/xcode10-zhong-yong-dao-libstdc609tbd-dao-zhi-de-wen-ti/"},{"title":"iOS 利用 Runtime 自定义导航控制器返回手势","content":" 自 iOS7 之后，系统的导航控制器就具备了 边缘滑动返回 的功能。 这一改进，使得用户能够很方便的退出当前页面，大屏的用户也不用再费力的去点击导航栏上的返回按钮，很是人性化。 但是，有些用户觉得这样还是不方便。只能从边缘滑动哪行？我要的是全屏都能滑！ 于是乎，很多应用，比如 QQ、知乎等都实现了这一功能。 想要实现这一功能，有好多种方法。 本文要介绍的这种方法，是比较好玩的一种方法。 因为我们用到了苹果私有的 API。 虽然违反了苹果的审核政策，但我们自有办法能躲过苹果的检测。 下面，就来聊一下实现过程。 1. 首先，我们需要知道系统的侧滑手势是如何实现的； 这个手势属于 UINavigationController，我们就跳到它的头文件里看看能不能找到线索。这个思路是正确的，确实有一个手势叫做 interactivePopGestureRecognizer。属性为 readonly，就是说我们不能给他换成自定义的手势，但是可以设置 enable=NO。那，既然找到了它，就打印一下，看看它到底是一个什么手势。 &lt; UIScreenEdgePanGestureRecognizer: 0x7f99d1e10ba0; state = Possible; delaysTouchesBegan = YES; view = &lt;UILayoutContainerView 0x7f99d1e0b7f0&gt;; target= &lt;(action=handleNavigationTransition:, target=&lt;_UINavigationInteractiveTransition 0x7f99d1e0fc10&gt;)&gt; &gt; 可以看到，这个手势属于 UIScreenEdgePanGestureRecognizer 这个类，它继承自 UIPanGestureRecognizer，是专门处理边缘手势的一个类。我们可以通过打印发现它的 target：_UINavigationInteractiveTransition（这是一个私有的类，用于处理导航栏动画的），action：handleNavigationTransition: (这个就是系统实现导航栏动画的私有方法)。我们要做的，就是自己新建一个 UIPanGestureRecognizer 手势，让它的 target 和 action 和系统的相同。 2. 以非常规手法获取系统手势； 我们要获取系统的侧滑手势的 target，用常规的手法肯定是获取不到的。 因为这是系统私有属性。 我们需要用 runtime 遍历它的成员变量，看一下系统是如何存储这个属性的。 unsigned int count; Ivar *ivar = class_copyIvarList([UIGestureRecognizer class], &amp;count); for (int i = 0; i &lt; count; i++) { Ivar var = ivar[i]; NSLog(@&quot;type:===&gt;%s&quot;,ivar_getTypeEncoding(var)); NSLog(@&quot;name:===&gt;%s&quot;,ivar_getName(var)); } 下面是打印结果，此处只取了两条有用的结果： 2015-09-24 15:10:30.879 Nav[1897:149271] type:===&gt;@&quot;NSMutableArray&quot; 2015-09-24 15:10:30.879 Nav[1897:149271] name:===&gt;_targets 我们再来打印一下这个 _targets 数组，看看里面是什么: NSMutableArray *_targets = [systemPopGes valueForKey:@&quot;_targets&quot;]; NSLog(@&quot;%@&quot;,_targets); 打印结果如下： (&quot;(action=handleNavigationTransition:, target=&lt;_UINavigationInteractiveTransition 0x7fcd0b5195c0&gt;)&quot;) 可以看到，可变数组里存储的，就是系统实现 导航栏动画 的 target 和 action，获取这个数组的 key 就是 _targets。 3. 以自己的手势，替换系统的手势； 我们可以通过 KVC 获取系统存储这个 target-action 的 数组，然后获取系统的 target-action，自己创建一个滑动手势，加入到系统实现侧滑手势所在的 view 中，禁用系统的侧滑手势，我们自定义的手势就可以代替系统的手势，实现滑动了。 代码如下： #import &quot;SYRNavigationController.h&quot; #import &lt;objc/runtime.h&gt; @interface SYRNavigationController () &lt;UIGestureRecognizerDelegate&gt; @end @implementation SYRNavigationController - (void)viewDidLoad { [super viewDidLoad]; // 获取系统原有侧滑手势 UIGestureRecognizer *systemPopGes = self.interactivePopGestureRecognizer; // 禁用系统侧滑手势 systemPopGes.enabled = NO; // 自定义滑动手势 UIPanGestureRecognizer *syrPan = [[UIPanGestureRecognizer alloc] init]; syrPan.delegate = self; syrPan.maximumNumberOfTouches = 1; // 向系统实现侧滑手势的view中加入自定义的滑动手势 [systemPopGes.view addGestureRecognizer:syrPan]; self.navigationBarHidden = YES; //隐藏Tabbar // 获取系统手势的target数组 NSMutableArray *_targets = [systemPopGes valueForKey:@&quot;_targets&quot;]; /** * 获取它的唯一对象，我们知道它是一个叫UIGestureRecognizerTarget的私有类，它有一个属性叫_target */ id gestureRecognizerTarget = [_targets firstObject]; /** * 获取_target:_UINavigationInteractiveTransition，它有一个方法叫handleNavigationTransition: */ id navigationInteractiveTransition = [gestureRecognizerTarget valueForKey:@&quot;_target&quot;]; /** * 通过前面的打印，我们从控制台获取出来它的方法签名。 */ SEL handleTransition = NSSelectorFromString(@&quot;handleNavigationTransition:&quot;); /** * 创建一个与系统一模一样的手势，我们只把它的类改为UIPanGestureRecognizer */ [syrPan addTarget:navigationInteractiveTransition action:handleTransition]; } - (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer { // 这里有两个条件不允许的手势执行，1、当前控制器为根控制器；2、如果这个push、pop动画正在执行（私有属性） // 即在根视图或者正在滑动时禁用手势 return self.viewControllers.count != 0 &amp;&amp; ![[self valueForKey:@&quot;_isTransitioning&quot;] boolValue]; } @end 以上就是简单的实现了一个自定义导航栏滑动手势的 UINavigationController，只要继承这个导航控制器，就可以全局实现全屏侧滑手势，当然系统版本一定要在 iOS7.0 以上 才行。 4. 规避被拒的风险，私有API的调用的隐匿处理； 在刚开始的时候我说到这个方法涉及苹果私有 API，在发布时可能有被拒的风险，我们可以通过下面的方法简单的避免。 代码如下： NSString *selectorStringBegin = @&quot;handleNavigation&quot;; NSString *selectorStringEnd = @&quot;Transition:&quot;; NSString *selectorString = [NSString stringWithFormat:@&quot;%@%@&quot;,selectorStringBegin,selectorStringEnd]; SEL systemAction = NSSelectorFromString(selectorString); ","link":"https://shannonmyang.github.io/post/ios-li-yong-runtime-zi-ding-yi-dao-hang-kong-zhi-qi-fan-hui-shou-shi/"},{"title":"蒸红烧肉","content":" 过年时节前，突然想吃老家做法的红烧肉，搜寻网上所有的教程，都没有。 就凭着印象自己做了一遍，还挺成功。 配料： 八角、花椒、大葱、生姜、白砂糖、蜂蜜、老抽、海鲜酱、蚝油、料酒、食用盐、五花肉 步骤： 1. 铁锅放入足够淹没肉的冷水，放入花椒（少许、不宜多）、八角（三五个、不宜多）、大葱（三两段）、生姜（六至八片），大火，将水煮开，放入五花肉，七成熟（用筷子能扎透），关火，即可捞出。 2. 捞出煮过的肉，控水、放置到表皮等于常温；同时，开始配置蜂蜜水，按照水：蜂蜜 = 3:1的比例勾兑，总之不宜过于黏稠。 3. 备一口锅，倒入能淹没肉的食用油，大火烧开；同时，将配置勾兑好的蜂蜜水，均匀涂抹到肉的表皮上。 4. 等油烧开，将涂抹好蜂蜜的肉，放入油中开始油炸（油炸的过程中，注意盖上锅盖，防止溅身上热油花）。油炸大概三到五分钟，关火。以锅中的油不再溅油花为准，或者以五花肉的表皮油炸后起的皱皮为准，皆可。 5. 将油炸后的肉捞出，放置到表皮等于常温。用刀将油炸后的肉切成片状，将切好的肉，放入到易于后续拌均匀的盆中。 6. 配置拌料，食用盐（视个人口味和肉的多少来放）、海鲜酱（视肉的多少来放，可适量多一点）、蚝油（视肉的多少来放，一般三到五小勺即可）、老抽（视肉的多少来放，以每片肉都能上色为准）、白砂糖（视肉的多少来放，不适合过甜），将以上配料，搅拌均匀。 7. 将拌好的料，倒入放肉的盆中，开始拌肉（肉多的话，带上橡皮或者塑料手套搅拌；肉少的话，用筷子），将肉拌均匀，即可停止。 8. 取出瓷碗，将拌好的肉，装入碗中（不宜装的过满，因为会蒸出很多油溢出来）。在每碗中放入八角两个、花椒少许（不宜过多）、生姜三片。 9. 取出蒸锅，放入足量水，将装好肉和干料的瓷碗放入，大火开烧，从冒水蒸气的时候，开始计时，三个小时后，关火即可。（注意：期间需要每隔四十分钟左右看看锅中水量，防止水烧干。用天然气烧小锅的时候，尤其需要注意水量） ","link":"https://shannonmyang.github.io/post/zheng-hong-shao-rou/"},{"title":"《图解算法》阅读笔记","content":" 这本自买回来，就被我反反复复翻看，却总是看了一半忘了看到具体哪儿，而从头看起的算法类书籍。 现在，终于被我看完了。遂有此笔记。 仅当列表是有序的时候，二分查找才管用 大 O 表示法指出了算法运行时间的增速 算法运行时间是从其增速的角度度量的 Leigh Caldwell 在 Stack Overflow 上说的一句话，“如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。” 每个递归函数都有两部分，基线条件 (base case) 和 递归条件 (recursive case)。递归条件指的是函数调用自己，基线条件指的是函数不再调用自己，从而避免形成无限循环。 优化递归的调用栈，有 2 种方法 重新编写代码，转而使用循环 使用尾递归。这是一个高级的主题，不在本书的讨论范围内，另外，并非所有的语言都支持尾递归。 编写涉及数组的递归函数的时候，基线条件通常是数组为空或只包含一个元素。 Haskell 等函数式编程语言就没有循环，因此你只能使用递归来编写这样的函数。如果你对递归有深入的认识，函数式编程语言学习起来将更加容易。如果你喜欢递归或者想学习一门新语言，可以研究一下 Haskell。 散列表要避免冲突，需要有： 较低的装填因子 良好的散列函数 有向图中的边为箭头，箭头的方向指定了关系的方向。无向图中的边不带箭头，其中的关系是双向的。 广度优先搜索求最短路径，对于检查过的点，务必不要再去检查，否则会导致无限循环。 在无向图中，每条边都是一个环。迪杰斯特拉算法只能用于有向无环图 (directed acyclic graph, DAG)，如果有负权边，就不能使用迪杰斯特拉算法。 在有负权边的图中，要求最短路径，需要用到贝尔曼 - 福德算法 (Bellman-Ford algorithm) 贪心算法的理念：每步都采取最优解。每步都选择局部最优解，最终得到的就是全局最优解。 判断是否是 NP 完全问题 元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。 涉及 “所有组合” 的问题通常是 NP 完全问题。 不能将问题分成小问题，必须考虑各种可能的情况。这可能是 NP 完全问题。 如果问题涉及序列，（如旅行商问题中的城市序列）且难以解决，它可能就是 NP 完全问题。 如果问题涉及集合 (如广播台集合)，且难以解决，它可能就是 NP 完全问题。 如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是 NP 完全问题。 对于 NP 完全问题，还没有找到快速解决方案。 面临 NP 完全问题，最佳的做法是使用近似算法。 仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用。 每种动态规则解决方案都涉及网格。 没有放之四海皆准的计算动态规划的公式，动态规划是一门艺术。 git diff 命令指出两个文件的差异，使用的就是动态规划实现的。 布隆过滤器是一个概率型数据结构，它提供的答案有可能不对，但很可能是正确的。布隆过滤器非常适合用于不要求答案绝对准确的情况。 面临海量数据且只要求答案八九不离十时，可考虑使用概率型算法。 当前最安全的密码散列函数是 bcrypt，但没有任何东西是万无一失的。 SHA 散列函数是局部不敏感的，有一个字符变化，都会导致其散列值截然不同。有时候希望散列函数是局部敏感的。在这种情况下，可使用 Simhash。如果你对字符串做细微的修改，Simhash 生成的散列值也只存在细微的差别。这让你能够通过比较散列值来判断两个字符串的相似程度。需要检查两项内容的相似程序时，Simhash 很有用。 Google 使用 Simhash 来判断网页是否已搜集。 老师可以使用 Simhash 来判断学生的论文是否是从网上抄的。 Scribd 允许用户上传文档或图书，以便与人分享，但不希望用户上传有版权的内容。这个网站可使用 Simhash 来检查上传的内容是否与出版的小说类似，如果类似，就自动拒绝。 ","link":"https://shannonmyang.github.io/post/lesslesstu-jie-suan-fa-greatergreater-yue-du-bi-ji/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://shannonmyang.github.io/post/hello-gridea/"},{"title":"算法小记 · 不用四则运算做加法","content":" 写一个函数，求两个整数之和，要求在函数体内不得使用 +、-、*、/ 四则运算符号。 输入： 输入可能包含多个测试样例。 对于每个测试案例，输入为两个整数 x 和 y (1 &lt;= m, n &lt;= 1000000)。 输出： 对应每个测试案例，输出 x + y 的值。 样例输入： 1 2 11 18 样例输出： 3 29 首先，思考的是，不能用四则运算符，只能从别的角度来考虑。 那么，用过C语言的，自然就得考虑到C语言的优势之一 按位运算。 吾来打个样： #include &lt;stdio.h&gt; // 主要的方法是用与来求进位，用异或来求不进位的加法 unsigned int Add(unsigned int a, unsigned int b) { unsigned int sum, carry; do { // 按位异或运算 sum = a ^ b; // 按位与运算后，再进行按位左移运算 // &lt;&lt; 1 相当于 *2 carry = (a &amp; b) &lt;&lt; 1; a = sum; b = carry; } while (b != 0); // 对carry的值做判断，不满足条件的，则为正确的sum值 return a; } int main(int argc, const char * argv[]) { unsigned int x, y; while (scanf(&quot;%u%u&quot;, &amp;x, &amp;y) != EOF) { printf(&quot;%u\\n&quot;, Add(x, y)); } return 0; } 关于按位运算的些许补充(不了解的或遗忘了的，可以看看)： C 语言 和其它高级语言不同的是，它完全支持 按位运算符。这与 汇编语言 的 位操作 有些相似。 因为 位运算 得到了更多的底层优化，因此同样的功能它的 效率更高。 所谓 位运算，就是对一个 比特（Bit）位 进行操作。比特（Bit） 是一个电子元器件，8 个比特 构成 一个字节（Byte），它已经是 粒度最小 的 可操作单元 了。 // C语言中提供的六种按位运算符 &amp; 位逻辑与 | 位逻辑或 ^ 位逻辑异或 ~ 位逻辑反 &gt;&gt; 右移 &lt;&lt; 左移 标准的 C 语言其实并不支持二进制数字，只不过有些编译器自己进行了扩展，才支持二进制数字。换句话讲就是，并非所有的编译器都支持二进制数字，只有一部分编译器支持，并且跟编译器的版本还有关系。 C 语言中不能直接使用 二进制 数字，按位运算符 两边的操作数可以是十进制、八进制、十六进制，因为它们在内存中最终皆是以 二进制 的形式存储，按位运算符就是对这些 内存中 的 二进制位 进行运算。其他的位运算符也是相同的道理。 提醒：按位运算符 是根据内存中的二进制位进行运算的，而不是数据的二进制形式；其他位运算符也一样。 按位与运算 (&amp;) /* * 按位与运算 (&amp;) * 一个比特（Bit）位只有 0 和 1 两个取值，只有参与 &amp; 运算的两个位都为 1 时，结果才为 1，否则为 0。 * 例如：1 &amp; 1为 1，0 &amp; 0为 0，1 &amp; 0也为 0，这和逻辑运算符 &amp;&amp; 非常类似。 * * 0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 0010 //表示十进制的 2 (在内存中的的存储) * &amp; 0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 0001 //表示十进制的 1 (在内存中的的存储) * --------------------------------------------------- * 0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 0000 //表示十进制的 0 (在内存中的的存储) * */ int m = 2; int n = 1; printf(&quot;%d \\n&quot;, (m &amp; n)); //输出为 0 按位或运算 (|) /* * 按位或运算 (|) * 一个比特（Bit）位只有 0 和 1 两个取值，只要参与 | 运算的两个二进制位有一个为 1 时，结果就为 1，两个都为 0 时结果才为 0。 * 例如：1 | 1为 1，0 | 0为 0，1 | 0为 1，这和逻辑运算中的||非常类似。 * * 0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 0010 //表示十进制的 2 (在内存中的的存储) * | 0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 0001 //表示十进制的 1 (在内存中的的存储) * --------------------------------------------------- * 0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 0011 //表示十进制的 3 (在内存中的的存储) * */ int m = 2; int n = 1; printf(&quot;%d\\n&quot;, (m | n)); //输出为 3 按位异或运算 (^) /* * 按位异或运算（^） * 一个比特（Bit）位只有 0 和 1 两个取值，只要当参与 ^ 运算两个二进制位不同时，结果就为 1，相同时结果则为 0。 * 例如：0 ^ 1为 1，0 ^ 0为 0，1 ^ 1为 0。 * * 0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 0010 //表示十进制的 2 (在内存中的的存储) * ^ 0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 0001 //表示十进制的 1 (在内存中的的存储) * --------------------------------------------------- * 0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 0011 //表示十进制的 3 (在内存中的的存储) * */ int m = 2; int n = 1; printf(&quot;%d\\n&quot;, (m ^ n)); //输出为 3 取反运算 (~) /* * 取反运算（~） * 一个比特（Bit）位只有 0 和 1 两个取值，取反运算符~为单目运算符，右结合性，作用是对参与运算的二进制位取反。 * 例如：~1为 0，~0为 1，这和逻辑运算中的!非常类似。 * ~ 0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 0001 //表示十进制的 1 (在内存中的的存储) * --------------------------------------------------- * 1111 1111 -- 1111 1111 -- 1111 1111 -- 1111 1110 //表示十进制的 -2 (在内存中的的存储) * 在计算机中，负数以原码的补码形式表达。 * 正数的补码与原码相同，负数的补码为对该数的原码(除符号位外)逐位取反，然后在最后一位加 1。 * 二进制中，如果有符号， 最高位表示符号, 0 为正, 1 为负, * -2 的二进制原码是：1000 0000 -- 0000 0000 -- 0000 0000 - 0000 0010 * -2 的二进制补码是：1111 1111 -- 1111 1111 -- 1111 1111 - 1111 1101 * -2 的o二进制补码加1 是：1111 1111 -- 1111 1111 -- 1111 1111 -- 1111 1110 */ int n = 1; printf(&quot;%d\\n&quot;, (~ n)); //输出为 -2 左移运算 (&lt;&lt;) /* * 左移运算 (&lt;&lt;) * 一个比特（Bit）位只有 0 和 1 两个取值，左移运算符&lt;&lt; 就是把操作数的各个二进制位全部左移若干位，高位丢弃，低位补 0。 * * &lt;&lt; 0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 0001 //表示十进制的 1 (在内存中的的存储) * --------------------------------------------------- * 0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 1000 //表示十进制的 8 (在内存中的的存储) * */ int n = 1; printf(&quot;%d\\n&quot;, (n &lt;&lt; 3)); //输出为 8 右移运算（&gt;&gt;） /* * 右移运算 (&gt;&gt;) * 一个比特（Bit）位只有 0 和 1 两个取值，右移运算符&gt;&gt; 就是把操作数的各个二进制位全部右移若干位，低位丢弃，高位补 0 或 1。 * 如果数据的最高位是 0，那么就补 0；如果最高位是 1，那么就补 1。 * * &gt;&gt; 0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 0001 //表示十进制的 1 (在内存中的的存储) * --------------------------------------------------- * 0000 0000 -- 0000 0000 -- 0000 0000 -- 0000 0000 //表示十进制的 0 (在内存中的的存储) * */ int n = 1; printf(&quot;%d\\n&quot;, (n &gt;&gt; 3)); //输出为 0 ","link":"https://shannonmyang.github.io/post/suan-fa-xiao-ji-bu-yong-si-ze-yun-suan-zuo-jia-fa/"},{"title":"算法小记 · 斐波那契数列 + 青蛙跳台阶问题","content":" 写一个函数，输入 n ，求斐波那契数列中第 n 项的数值。 斐波那契数列定义如下： f(n)={0,n=0;x,n=1;f(n−1)+f(n−2),n&gt;1;f(n)=\\begin{cases} 0,\\quad n = 0; \\\\\\\\ x,\\quad n = 1;\\\\\\\\ f(n - 1) + f(n - 2),\\quad n &gt; 1;\\end{cases} f(n)=⎩⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎧​0,n=0;x,n=1;f(n−1)+f(n−2),n&gt;1;​ 1. 最基本的方法（运用递归） 这个解法是最基本的方法，但是存在很严重的效率问题。 用树形结构图来分析的话，你会发现很多重复的结点。而重复的结点数会随着n的增大而急剧增加，这就意味着计算量会随着n的增大而急剧增大，导致时间变得巨长无比。 有兴趣的可以尝试输入第86项试试，感受一下什么叫做巨慢无比。 吾来打个样： #include &lt;stdio.h&gt; /* 最基本的方法 */ long long Fibonacci(unsigned int n) { if(n &lt;= 0) return 0; //当只有一项的时候 if(n == 1) return 1; //当不止有一项的时候 return Fibonacci(n - 1) + Fibonacci(n - 2); } int main(int argc, const char * argv[]) { clock_t start, finish; double duration; /* 测量一个事件持续的时间*/ /* 起始 */ start = clock(); /* 要执行的代码，放在此处（两个clock方法的调用中间），方便测试出要执行的代码的执行时间 */ printf(&quot;%lld\\n&quot;, Fibonacci(11)); /* 结束 */ finish = clock(); /* 时间 */ duration = (double)(finish - start) / CLOCKS_PER_SEC; printf( &quot;Use time is %f seconds.\\n&quot;, duration ); return 0; } 2. 优化后的方法 其实改进的方法并不复杂，只需要避免1.最基本方法中的重复计算即可。 所以，我们可以把已经得到的数列中间项保存起来，如果下次需要计算的时候，先查找一下，如果已经计算过，就不用重复计算了。 当然，更简单的方法是，自下而上计算，首先根据f(0) 和f(1)算出f(2)，再根据f(1)和f(2)算出f(3)……依此类推，可以算出第n项。 那么，自然的，这种时间复杂度便是O(n)。 吾来打个样： #include &lt;stdio.h&gt; /* 优化后的方法 */ long long Fibonacci(unsigned n) { int result[2] = {0, 1}; if(n &lt; 2) return result[n]; long long fibNMinusOne = 1; long long fibNMinusTwo = 0; long long fibN = 0; for(unsigned int i = 2; i &lt;= n; ++ i) { fibN = fibNMinusOne + fibNMinusTwo; fibNMinusTwo = fibNMinusOne; fibNMinusOne = fibN; } return fibN; } int main(int argc, const char * argv[]) { clock_t start, finish; double duration; /* 测量一个事件持续的时间*/ /* 起始 */ start = clock(); /* 要执行的代码，放在此处（两个clock方法的调用中间），方便测试出要执行的代码的执行时间 */ printf(&quot;%lld\\n&quot;, Fibonacci(11)); /* 结束 */ finish = clock(); /* 时间 */ duration = (double)(finish - start) / CLOCKS_PER_SEC; printf( &quot;Use time is %f seconds.\\n&quot;, duration ); return 0; } 3. 青蛙跳台阶问题 假如有一只青蛙，一次可以跳上 1 级台阶，也可以跳 2 级台阶，请问青蛙上一个 n 级台阶一共有多少种跳法？ 分析如下： 假如现在台阶只有 1 级，n = 1，那么这只青蛙就在只有 1 种跳法：1（1 代表一次跳 1 级台阶）也就是 f(1) = 1 种跳法 假如现在台阶只有 2 级，n = 2，那么这只青蛙可以有 2 种跳法：1 1、2（1 代表一次跳 1 级台阶，2 代表一次跳 2 级台阶），也就是 f(2) = 2 种跳法 假如现在台阶有 3 级，n = 3，青蛙可以有几种跳法呢？ 假如青蛙先跳了 1 级台阶，还剩下 2 级台阶，那它还有几种跳法呢？通过第 2 个情况分析知道有 2 种跳法；假如青蛙先跳了 2 级台阶，根据第 1 个情况分析知道有 1 种跳法，所以这时候得出 f(3) = 2 + 1 种方法 假如现在台阶有 4 级，n = 4，我们利用上面的规律继续分析可得：f(4) = 3 + 2 综上所述，我们得出其实这个算法就是一个（变形）斐波那契数列问题，公式如下： n = 1, f(1) = 1 n = 2, f(2) = 2 n &gt; 2, f(n) = f(n -1) + f(n -2) 所以至此明白了，青蛙跳台阶问题就是一个（变形）斐波那契数列问题。 吾来打个样： #include &lt;stdio.h&gt; /* 优化后的方法 */ long long Fibonacci(unsigned n) { int result[2] = {0, 1, 2}; if(n &lt;= 2) return result[n]; long long fibNMinusOne = 2; long long fibNMinusTwo = 1; long long fibN = 0; for(unsigned int i = 3; i &lt;= n; ++ i) { fibN = fibNMinusOne + fibNMinusTwo; fibNMinusTwo = fibNMinusOne; fibNMinusOne = fibN; } return fibN; } int main(int argc, const char * argv[]) { clock_t start, finish; double duration; /* 测量一个事件持续的时间*/ /* 起始 */ start = clock(); /* 要执行的代码，放在此处（两个clock方法的调用中间），方便测试出要执行的代码的执行时间 */ printf(&quot;%lld\\n&quot;, Fibonacci(11)); /* 结束 */ finish = clock(); /* 时间 */ duration = (double)(finish - start) / CLOCKS_PER_SEC; printf( &quot;Use time is %f seconds.\\n&quot;, duration ); return 0; } ","link":"https://shannonmyang.github.io/post/suan-fa-xiao-ji-fei-bo-na-qi-shu-lie-qing-wa-tiao-tai-jie-wen-ti/"},{"title":"再写 iOS 响应者链","content":" 最近看到群里讨论有关响应者链的相关面试题。扪心自问，知道一部分，但是不够全。给自己一种青黄不接的感觉。 遂，决定温故一下 iOS 响应者连。再细细看看，发现一下以前没注意的地方。 iOS 事件传递和响应机制 1. 按时间顺序，事件的生命周期如下： 事件的产生和传递 (事件如何从父控件传递到子控件并寻找到最适合的 view、寻找最合适的 view 的底层实现、拦截事件的处理 --&gt; 找到最合适的 view 后事件的处理（touches 方法的重写，也就是事件的响应） 2. 难点和重点： a. 怎样找到最合适的 view； b. 找到最合适的 view 的底层实现（即 - (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event; 的实现）； 3. iOS 中的事件： a. 触摸事件 b. 加速计事件 c. 远程控制事件 4. 响应者对象 (UIResponder)： iOS 中，只有继承了 UIResponder 的对象才能接受并处理事件。我们称之为 “响应者对象”； 比如： a. UIApplication b. UIViewController c. UIView 5. 事件的处理： 为什么继承自 UIResponder 的类就能接收并处理事件？ // 因为 UIResponder 中提供了4个对象方法来处理事件； // 以 UIView 为例来说明触摸事件的处理； // UIView 是 UIResponder 的子类，可以用覆盖下列4个方法处理不同的触摸事件； // 一或多根手指开始触摸 view ，系统会自动调用下面的 view 方法； - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event; // 一或多根手指离开 view ，系统会自动调用下面的方法； - (void)touchesEnded:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event; // 一或多根手指在 view 上移动，系统会自动调用下面的方法（并且，随着手指的持续移动，会持续调用该方法） - (void)touchesMoved:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event; // 触摸结束前，某个系统事件（如电话呼入）会打断触摸过程，系统会自动调用下面的方法； - (void)touchesCancelled:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event; // 提示：touches 中存放的是 UITouch 对象； 需要注意的是：以上四个方法是由系统自动调用的。 所以，可以通过重写以上四种方法来处理一些事件。 当用户用一根手指触摸屏幕时，会创建一个与手指相关的 UITouch 对象； 如果两根手指同时触摸一个 view，那么 view 只会调用一次 - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event; 方法，touches 参数中装着 2 个 UITouch 对象； 如果这两根手指一前一后分开触摸同一个 view，那么 view 会分别调用 2 次 - (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event; 方法，并且每次调用时的 touches 参数中只包含一个 UITouch 对象； 重写以上四个方法，如果是处理 UIView 的触摸事件。必须自定义一个继承自 UIView 的子类。由于 Apple 不开源一些 Objective-C 源码。所以，只能通过子类继承父类，重写方法的方式来处理 UIView 的触摸事件； 上面说的是处理 UIView 触摸事件，而不是 UIViewController 的触摸事件。要处理 UIViewController 的触摸事件，在控制器内直接重写以上四个方法即可； 6. UITouch 的作用： 保存着跟手势相关的信息，比如触摸的位置、时间、阶段； 当指针移动时，系统会更新同一个 UITouch 对象，使之能够一直保持该手指在触摸的位置； 当手指离开屏幕的时候，系统会自动调用方法，销毁相应的 UITouch 对象； 提示：iOS 开发中，要尽量避免使用双击事件； 7. iOS 事件的产生和传递： a. 事件的产生： 发生触摸事件后，系统会将该事件加入到一个由 UIApplication 管理的事件队列中，为什么是队列而不是栈？因为队列的特点是 FIFO，即先进先出。先产生的事件先处理才符合正常逻辑（即日常生活所见），所以把事件添加到队列。 UIApplication 会从事件队列中取出最前面的事件，并将事件分发下去以便处理。通常，会先把事件发送给应用程序的主窗口（即 keyWindow）。 主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，这也是整个事件处理过程的第一步。找到合适的视图控件后，就会调用视图控件的 touches 方法来作具体的事件处理。 b. 事件的传递 ","link":"https://shannonmyang.github.io/post/zai-xie-ios-xiang-ying-zhe-lian/"},{"title":"iOS 事件响应","content":" 写这篇笔记是源于最近有朋友问到的一个问题：在 UIView 上添加若干子视图，子视图之间互为兄弟视图，如何让那些在父视图外面的子视图响应事件？ 认真想了下，这应该是 iOS 中的一个基础知识点：事件的传递和响应 ，而我们要做的是，拦截下这个事件。 那么，来简单分析下，按照时间轴来划分，事件的生命周期大概是这样： 1、 事件的产生与传递（事件是怎么从父级 UI 控件传递到子级 UI 控件并找到最合适 view 的、寻找最合适的 view 的底层是如何实现的、咋进行拦截事件的处理） 2、 找到最合适的 view 后事件的处理（将 touches 方法重写，也就是所谓的事件的响应） 事件的传递已经被很多人讲过了，有需要的可自行搜索查看，在此，一笔带过。 传递过程大致如下： UIApplication -&gt; UIWindow -&gt; UI控件(Father) -&gt; UI控件(Son) 这里主要记录了如何拦截。 子视图响应事件是有一个范围的 子视图被添加到父视图以后，每次在屏幕上的点击事件都会触发一条响应链来逐层判断该由哪个视图来响应事件。当一个自视图添加到父视图以后其响应事件的范围就是父视图的 bounds，如果子视图的 bounds 超出了父视图则超出的部分就会被响应链判断为不能响应事件而被抛弃。 写一个 Demo，如图所示。父视图，红色区域，是 UIView，我们下文称为大红；子视图均为兄弟视图，是 UIButton；1 号称为小蓝；2 号称为小黑；3 号称为小灰。 Ps:1、2、3 号按钮，是依次添加到父视图 大红 上的。每个 UIButton 都对应着一个点击事件响应方法，均做 NSLog 打印。 在默认情况下，点击 UIButton 就会触发其对应的方法，做打印。 //类似这样 - (void)firstLog:(UIButton *)button { NSLog(@&quot;111111111&quot;); } 然而，实际的情况却是，分别点击三个按钮发现: 内部的 1 号按钮即 小蓝 每次的按钮点击事件 都能响应 ；而接近于边上的 2 号按钮 小黑 则 有时响应 ， 有时不会 ；至于外部的 3 号按钮 小灰 ，则 完全不响应 。 这是因为，虽然三个按钮都可见，但是只要不是在父视图的 bounds 内的部分便无法响应点击，边界上的按钮只有部分在其父视图之内，所以不是每次点击都会响应，只有点击其在父视图之内的部分（即交叉部分）才能响应点击。 如果要实现点击 2号按钮 小黑 的任意区域均可打印，点击 3号按钮 小灰 也可打印。 则需要在 大红 也就是父视图重写 - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event 方法。 因为– hitTest:withEvent: 是通过 - pointInside:withEvent: 来判断点击的点是否在视图中。然后判断这个视图是否接受当前事件，关于 - pointInside:withEvent: 这个方法在官方文档中说明了，正是通过 bounds 判断的。 所以，超出父视图的子视图响应事件，该这么做。 在父视图添加如下代码。其思路是：遍历父视图的所有子视图，并判断触发事件的点是否在子视图的 bounds 内。如果在，就返回这个子视图。 - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event { UIView *view = [super hitTest:point withEvent:event]; if (view == nil) { for (UIView *subView in self.subviews) { CGPoint p = [subView convertPoint:point fromView:self]; if (CGRectContainsPoint(subView.bounds, p)) { view = subView; } } } return view; } 如果要实现，点击 3号按钮 小灰，却让 2号按钮 小黑 响应，打印出来。 也需要在 大红 也就是父视图重写 - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event 方法，并在其中拦截，让 2 号按钮小黑响应点击事件。 - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event { UIView *view = [super hitTest:point withEvent:event]; if (view == nil) { for (UIView *subView in self.subviews) { if (subView == self.subviews[1]) { view = subView; } } } return view; } ","link":"https://shannonmyang.github.io/post/ios-shi-jian-xiang-ying/"}]}